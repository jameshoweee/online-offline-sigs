
;; Function __sputc_r (null)
;; enabled by -tree-original


{
  if ( --_p->_w >= 0 || _p->_w >= _p->_lbfsize && (unsigned char) _c != 10)
    {
      return (int) (*_p->_p++  = (unsigned char) _c);
    }
  else
    {
      return __swbuf_r (_ptr, _c, _p);
    }
}


;; Function _getchar_unlocked (null)
;; enabled by -tree-original


{
  struct _reent * _ptr;

    struct _reent * _ptr;
  _ptr = _impure_ptr;
  return  --_ptr->_stdin->_r < 0 ? __srget_r (_ptr, (struct FILE *) _ptr->_stdin) : (int) *_ptr->_stdin->_p++ ;
}


;; Function _putchar_unlocked (null)
;; enabled by -tree-original


{
  struct _reent * _ptr;

    struct _reent * _ptr;
  _ptr = _impure_ptr;
  return __sputc_r (_ptr, _c, (struct FILE *) _ptr->_stdout);
}


;; Function set_fpu_cw (null)
;; enabled by -tree-original


{
  return x;
}


;; Function fpr_ursh (null)
;; enabled by -tree-original


{
  x = (long long unsigned int) (x >> 32 ^ x) & -(long long unsigned int) (n >> 5) ^ (long long unsigned int) x;
  return x >> (n & 31);
}


;; Function fpr_irsh (null)
;; enabled by -tree-original


{
  x = (long long int) (x >> 32 ^ x) & -(long long int) (n >> 5) ^ (long long int) x;
  return x >> (n & 31);
}


;; Function fpr_ulsh (null)
;; enabled by -tree-original


{
  x = (long long unsigned int) (x << 32 ^ x) & -(long long unsigned int) (n >> 5) ^ (long long unsigned int) x;
  return x << (n & 31);
}


;; Function FPR (null)
;; enabled by -tree-original


{
  fpr x;
  uint32_t t;
  unsigned int f;

    fpr x;
    uint32_t t;
    unsigned int f;
  e = e + 1076;
  t = (long unsigned int) e >> 31;
  m = (long long unsigned int) t + 18446744073709551615 & (long long unsigned int) m;
  t = (long unsigned int) (m >> 54);
  e = -(int) t & e;
  x = ((long long unsigned int) s << 63 | (long long unsigned int) (m >> 2)) + ((long long unsigned int) (long unsigned int) e << 52);
  f = (unsigned int) m & 7;
  x = ((fpr) (200 >> f) & 1) + x;
  return x;
}


;; Function fpr_of (null)
;; enabled by -tree-original


{
  return falcon_inner_fpr_scaled (i, 0);
}


;; Function fpr_rint (null)
;; enabled by -tree-original


{
  uint64_t m;
  uint64_t d;
  int e;
  uint32_t s;
  uint32_t dd;
  uint32_t f;

    uint64_t m;
    uint64_t d;
    int e;
    uint32_t s;
    uint32_t dd;
    uint32_t f;
  m = (long long unsigned int) (x << 10) & 4611686018427387903 | 4611686018427387904;
  e = 1085 - ((int) (x >> 52) & 2047);
  m = -(long long unsigned int) ((long unsigned int) (e + -64) >> 31) & (long long unsigned int) m;
  e = e & 63;
  d = fpr_ulsh (m, 63 - e);
  dd = (long unsigned int) d | (long unsigned int) (d >> 32) & 536870911;
  f = (long unsigned int) (d >> 61) | (long unsigned int) ((-dd | dd) >> 31);
  m = (long long unsigned int) fpr_ursh (m, e) + ((long long unsigned int) (200 >> f) & 1);
  s = (long unsigned int) (x >> 63);
  return (int64_t) ((-(long long int) s ^ (long long int) m) + (long long int) s);
}


;; Function fpr_floor (null)
;; enabled by -tree-original


{
  uint64_t t;
  int64_t xi;
  int e;
  int cc;

    uint64_t t;
    int64_t xi;
    int e;
    int cc;
  e = (int) (x >> 52) & 2047;
  t = x >> 63;
  xi = (long long int) ((long long unsigned int) (x << 10) | 4611686018427387904) & 9223372036854775807;
  xi = (-(long long int) t ^ (long long int) xi) + (long long int) t;
  cc = 1085 - e;
  xi = fpr_irsh (xi, cc & 63);
  xi = (-(long long int) t ^ (long long int) xi) & -(long long int) ((long unsigned int) (63 - cc) >> 31) ^ (long long int) xi;
  return xi;
}


;; Function fpr_trunc (null)
;; enabled by -tree-original


{
  uint64_t t;
  uint64_t xu;
  int e;
  int cc;

    uint64_t t;
    uint64_t xu;
    int e;
    int cc;
  e = (int) (x >> 52) & 2047;
  xu = (long long unsigned int) (x << 10) & 4611686018427387903 | 4611686018427387904;
  cc = 1085 - e;
  xu = fpr_ursh (xu, cc & 63);
  xu = -(long long unsigned int) ((long unsigned int) (cc + -64) >> 31) & (long long unsigned int) xu;
  t = x >> 63;
  xu = (-t ^ xu) + t;
  return *(int64_t *) &xu;
}


;; Function fpr_sub (null)
;; enabled by -tree-original


{
  y = (long long unsigned int) y ^ 9223372036854775808;
  return falcon_inner_fpr_add (x, y);
}


;; Function fpr_neg (null)
;; enabled by -tree-original


{
  x = (long long unsigned int) x ^ 9223372036854775808;
  return x;
}


;; Function fpr_half (null)
;; enabled by -tree-original


{
  uint32_t t;

    uint32_t t;
  x = (long long unsigned int) x + 18442240474082181120;
  t = ((long unsigned int) (x >> 52) & 2047) + 1 >> 11;
  x = (long long unsigned int) t + 18446744073709551615 & (long long unsigned int) x;
  return x;
}


;; Function fpr_double (null)
;; enabled by -tree-original


{
  x = ((long long unsigned int) (((unsigned int) (x >> 52) & 2047) + 2047 >> 11) << 52) + (long long unsigned int) x;
  return x;
}


;; Function fpr_sqr (null)
;; enabled by -tree-original


{
  return falcon_inner_fpr_mul (x, x);
}


;; Function fpr_inv (null)
;; enabled by -tree-original


{
  return falcon_inner_fpr_div (4607182418800017408, x);
}


;; Function fpr_lt (null)
;; enabled by -tree-original


{
  int cc0;
  int cc1;

    int cc0;
    int cc1;
  cc0 = *(int64_t *) &x < *(int64_t *) &y;
  cc1 = *(int64_t *) &x > *(int64_t *) &y;
  return (cc0 ^ cc1) & (int) ((x & y) >> 63) ^ cc0;
}


;; Function prng_get_u64 (null)
;; enabled by -tree-original


{
  size_t u;

    size_t u;
  u = p->ptr;
  if (u > 502)
    {
      falcon_inner_prng_refill (p);
      u = 0;
    }
  p->ptr = u + 8;
  return (uint64_t) ((((((((long long unsigned int) p->buf.d[u] | (long long unsigned int) p->buf.d[u + 1] << 8) | (long long unsigned int) p->buf.d[u + 2] << 16) | (long long unsigned int) p->buf.d[u + 3] << 24) | (long long unsigned int) p->buf.d[u + 4] << 32) | (long long unsigned int) p->buf.d[u + 5] << 40) | (long long unsigned int) p->buf.d[u + 6] << 48) | (long long unsigned int) p->buf.d[u + 7] << 56);
}


;; Function prng_get_u8 (null)
;; enabled by -tree-original


{
  unsigned int v;

    unsigned int v;
  v = (unsigned int) p->buf.d[p->ptr++ ];
  if (p->ptr == 512)
    {
      falcon_inner_prng_refill (p);
    }
  return v;
}


;; Function shake256_init (null)
;; enabled by -tree-original


{
  falcon_inner_i_shake256_init ((struct inner_shake256_context *) sc);
}


;; Function shake256_inject (null)
;; enabled by -tree-original


{
  falcon_inner_i_shake256_inject ((struct inner_shake256_context *) sc, (const uint8_t *) data, len);
}


;; Function shake256_flip (null)
;; enabled by -tree-original


{
  falcon_inner_i_shake256_flip ((struct inner_shake256_context *) sc);
}


;; Function shake256_extract (null)
;; enabled by -tree-original


{
  falcon_inner_i_shake256_extract ((struct inner_shake256_context *) sc, (uint8_t *) out, len);
}


;; Function shake256_init_prng_from_seed (null)
;; enabled by -tree-original


{
  shake256_init (sc);
  shake256_inject (sc, seed, seed_len);
  shake256_flip (sc);
}


;; Function shake256_init_prng_from_system (null)
;; enabled by -tree-original


{
  uint8_t seed[48];

    uint8_t seed[48];
  if (falcon_inner_get_seed ((void *) &seed, 48) == 0)
    {
      return -1;
    }
  shake256_init (sc);
  shake256_inject (sc, (const void *) &seed, 48);
  shake256_flip (sc);
  return 0;
}


;; Function align_u64 (null)
;; enabled by -tree-original


{
  uint8_t * atmp;
  unsigned int off;

    uint8_t * atmp;
    unsigned int off;
  atmp = (uint8_t *) tmp;
  off = (unsigned int) atmp & 7;
  if (off != 0)
    {
      atmp = atmp + (sizetype) (8 - off);
    }
  return atmp;
}


;; Function align_u16 (null)
;; enabled by -tree-original


{
  uint8_t * atmp;

    uint8_t * atmp;
  atmp = (uint8_t *) tmp;
  if (((unsigned int) atmp & 1) != 0)
    {
      atmp++ ;
    }
  return atmp;
}


;; Function align_fpr (null)
;; enabled by -tree-original


{
  uint8_t * atmp;
  unsigned int off;

    uint8_t * atmp;
    unsigned int off;
  atmp = (uint8_t *) tmp;
  off = (unsigned int) atmp & 7;
  if (off != 0)
    {
      atmp = atmp + (sizetype) (8 - off);
    }
  return (fpr *) atmp;
}


;; Function falcon_keygen_make (null)
;; enabled by -tree-original


{
  int8_t * f;
  int8_t * g;
  int8_t * F;
  uint16_t * h;
  uint8_t * atmp;
  size_t n;
  size_t u;
  size_t v;
  size_t sk_len;
  size_t pk_len;
  uint8_t * sk;
  uint8_t * pk;
  unsigned int oldcw;

    int8_t * f;
    int8_t * g;
    int8_t * F;
    uint16_t * h;
    uint8_t * atmp;
    size_t n;
    size_t u;
    size_t v;
    size_t sk_len;
    size_t pk_len;
    uint8_t * sk;
    uint8_t * pk;
    unsigned int oldcw;
  if (logn + 4294967295 > 9)
    {
      return -5;
    }
  if (((logn <= 3 ? (size_t) ((3 << logn) + 1) : (size_t) (((10 - (logn >> 1) << logn + 4294967294) + (unsigned int) (1 << logn)) + 1)) > privkey_len || pubkey != 0B && (logn > 1 ? (size_t) ((7 << logn + 4294967294) + 1) : 5) > pubkey_len) || (size_t) (((logn > 3 ? 28 << logn : 272) + (3 << logn)) + 7) > tmp_len)
    {
      return -2;
    }
  n = 1 << logn;
  f = (int8_t *) tmp;
  g = f + (sizetype) n;
  F = g + (sizetype) n;
  atmp = align_u64 ((void *) (F + (sizetype) n));
  oldcw = set_fpu_cw (2);
  falcon_inner_keygen ((struct inner_shake256_context *) rng, f, g, F, 0B, 0B, logn, atmp);
  set_fpu_cw (oldcw);
  sk = (uint8_t *) privkey;
  sk_len = logn <= 3 ? (3 << logn) + 1 : ((10 - (logn >> 1) << logn + 4294967294) + (unsigned int) (1 << logn)) + 1;
  *sk = (uint8_t) logn + 80;
  u = 1;
  v = falcon_inner_trim_i8_encode ((void *) (sk + (sizetype) u), sk_len - u, (const int8_t *) f, logn, (unsigned int) falcon_inner_max_fg_bits[logn]);
  if (v == 0)
    {
      return -6;
    }
  u = u + v;
  v = falcon_inner_trim_i8_encode ((void *) (sk + (sizetype) u), sk_len - u, (const int8_t *) g, logn, (unsigned int) falcon_inner_max_fg_bits[logn]);
  if (v == 0)
    {
      return -6;
    }
  u = u + v;
  v = falcon_inner_trim_i8_encode ((void *) (sk + (sizetype) u), sk_len - u, (const int8_t *) F, logn, (unsigned int) falcon_inner_max_FG_bits[logn]);
  if (v == 0)
    {
      return -6;
    }
  u = u + v;
  if (u != sk_len)
    {
      return -6;
    }
  if (pubkey != 0B)
    {
      h = (uint16_t *) align_u16 ((void *) (g + (sizetype) n));
      atmp = (uint8_t *) (h + (sizetype) (n * 2));
      if (falcon_inner_compute_public (h, (const int8_t *) f, (const int8_t *) g, logn, atmp) == 0)
        {
          return -6;
        }
      pk = (uint8_t *) pubkey;
      pk_len = logn > 1 ? (7 << logn + 4294967294) + 1 : 5;
      *pk = (uint8_t) logn;
      v = falcon_inner_modq_encode ((void *) (pk + 1), pk_len + 4294967295, (const uint16_t *) h, logn);
      if (pk_len + 4294967295 != v)
        {
          return -6;
        }
    }
  return 0;
}


;; Function falcon_make_public (null)
;; enabled by -tree-original


{
  uint8_t * pk;
  uint8_t * atmp;
  const uint8_t * sk;
  unsigned int logn;
  size_t u;
  size_t v;
  size_t n;
  size_t pk_len;
  int8_t * f;
  int8_t * g;
  uint16_t * h;

    uint8_t * pk;
    uint8_t * atmp;
    const uint8_t * sk;
    unsigned int logn;
    size_t u;
    size_t v;
    size_t n;
    size_t pk_len;
    int8_t * f;
    int8_t * g;
    uint16_t * h;
  if (privkey_len == 0)
    {
      return -3;
    }
  sk = (const uint8_t *) privkey;
  if (((int) *sk & 240) != 80)
    {
      return -3;
    }
  logn = (unsigned int) *sk & 15;
  if (logn + 4294967295 > 9)
    {
      return -3;
    }
  if ((logn <= 3 ? (size_t) ((3 << logn) + 1) : (size_t) (((10 - (logn >> 1) << logn + 4294967294) + (unsigned int) (1 << logn)) + 1)) != privkey_len)
    {
      return -3;
    }
  if ((logn > 1 ? (size_t) ((7 << logn + 4294967294) + 1) : 5) > pubkey_len || (size_t) ((6 << logn) + 1) > tmp_len)
    {
      return -2;
    }
  n = 1 << logn;
  f = (int8_t *) tmp;
  g = f + (sizetype) n;
  u = 1;
  v = falcon_inner_trim_i8_decode (f, logn, (unsigned int) falcon_inner_max_fg_bits[logn], (const void *) (sk + (sizetype) u), privkey_len - u);
  if (v == 0)
    {
      return -3;
    }
  u = u + v;
  v = falcon_inner_trim_i8_decode (g, logn, (unsigned int) falcon_inner_max_fg_bits[logn], (const void *) (sk + (sizetype) u), privkey_len - u);
  if (v == 0)
    {
      return -3;
    }
  h = (uint16_t *) align_u16 ((void *) (g + (sizetype) n));
  atmp = (uint8_t *) (h + (sizetype) (n * 2));
  if (falcon_inner_compute_public (h, (const int8_t *) f, (const int8_t *) g, logn, atmp) == 0)
    {
      return -3;
    }
  pk = (uint8_t *) pubkey;
  pk_len = logn > 1 ? (7 << logn + 4294967294) + 1 : 5;
  *pk = (uint8_t) logn;
  v = falcon_inner_modq_encode ((void *) (pk + 1), pk_len + 4294967295, (const uint16_t *) h, logn);
  if (pk_len + 4294967295 != v)
    {
      return -6;
    }
  return 0;
}


;; Function falcon_get_logn (null)
;; enabled by -tree-original


{
  int logn;

    int logn;
  if (len == 0)
    {
      return -3;
    }
  logn = (int) *(uint8_t *) obj & 15;
  if ((unsigned int) logn + 4294967295 > 9)
    {
      return -3;
    }
  return logn;
}


;; Function falcon_sign_start (null)
;; enabled by -tree-original


{
  shake256_extract (rng, nonce, 40);
  shake256_init (hash_data);
  shake256_inject (hash_data, (const void *) nonce, 40);
  return 0;
}


;; Function falcon_sign_dyn_finish (null)
;; enabled by -tree-original


{
  unsigned int logn;
  const uint8_t * sk;
  uint8_t * es;
  int8_t * f;
  int8_t * g;
  int8_t * F;
  int8_t * G;
  uint16_t * hm;
  int16_t * sv;
  uint8_t * atmp;
  size_t u;
  size_t v;
  size_t n;
  size_t es_len;
  unsigned int oldcw;
  struct inner_shake256_context sav_hash_data;

    unsigned int logn;
    const uint8_t * sk;
    uint8_t * es;
    int8_t * f;
    int8_t * g;
    int8_t * F;
    int8_t * G;
    uint16_t * hm;
    int16_t * sv;
    uint8_t * atmp;
    size_t u;
    size_t v;
    size_t n;
    size_t es_len;
    unsigned int oldcw;
    struct inner_shake256_context sav_hash_data;
  if (privkey_len == 0)
    {
      return -3;
    }
  sk = (const uint8_t *) privkey;
  if (((int) *sk & 240) != 80)
    {
      return -3;
    }
  logn = (unsigned int) *sk & 15;
  if (logn + 4294967295 > 9)
    {
      return -3;
    }
  if ((logn <= 3 ? (size_t) ((3 << logn) + 1) : (size_t) (((10 - (logn >> 1) << logn + 4294967294) + (unsigned int) (1 << logn)) + 1)) != privkey_len)
    {
      return -3;
    }
  if ((size_t) ((78 << logn) + 7) > tmp_len)
    {
      return -2;
    }
  es_len = *sig_len;
  if (es_len <= 40)
    {
      return -2;
    }
  switch (sig_type)
    {
      case 1:;
      goto <D.7983>;
      case 2:;
      if (*sig_len < (size_t) (((((((256 >> 10 - logn) * 3 + (128 >> 10 - logn) * 2) + (64 >> 10 - logn) * 3) + (16 >> 10 - logn) * 2) - (2 >> 10 - logn) * 2) - (1 >> 10 - logn) * 8) + 44))
        {
          return -2;
        }
      goto <D.7983>;
      case 3:;
      if (*sig_len < (size_t) (((3 << logn + 4294967295) - (logn == 3)) + 41))
        {
          return -2;
        }
      goto <D.7983>;
      default:;
      return -5;
      <D.7983>:;
    }
  n = 1 << logn;
  f = (int8_t *) tmp;
  g = f + (sizetype) n;
  F = g + (sizetype) n;
  G = F + (sizetype) n;
  hm = (uint16_t *) (G + (sizetype) n);
  sv = (int16_t *) hm;
  atmp = align_u64 ((void *) (hm + (sizetype) (n * 2)));
  u = 1;
  v = falcon_inner_trim_i8_decode (f, logn, (unsigned int) falcon_inner_max_fg_bits[logn], (const void *) (sk + (sizetype) u), privkey_len - u);
  if (v == 0)
    {
      return -3;
    }
  u = u + v;
  v = falcon_inner_trim_i8_decode (g, logn, (unsigned int) falcon_inner_max_fg_bits[logn], (const void *) (sk + (sizetype) u), privkey_len - u);
  if (v == 0)
    {
      return -3;
    }
  u = u + v;
  v = falcon_inner_trim_i8_decode (F, logn, (unsigned int) falcon_inner_max_FG_bits[logn], (const void *) (sk + (sizetype) u), privkey_len - u);
  if (v == 0)
    {
      return -3;
    }
  u = u + v;
  if (u != privkey_len)
    {
      return -3;
    }
  if (falcon_inner_complete_private (G, (const int8_t *) f, (const int8_t *) g, (const int8_t *) F, logn, atmp) == 0)
    {
      return -3;
    }
  shake256_flip (hash_data);
  sav_hash_data = *(struct inner_shake256_context *) hash_data;
  <D.7993>:;
  *(struct inner_shake256_context *) hash_data = sav_hash_data;
  if (sig_type == 3)
    {
      falcon_inner_hash_to_point_ct ((struct inner_shake256_context *) hash_data, hm, logn, atmp);
    }
  else
    {
      falcon_inner_hash_to_point_vartime ((struct inner_shake256_context *) hash_data, hm, logn);
    }
  oldcw = set_fpu_cw (2);
  falcon_inner_sign_dyn (sv, (struct inner_shake256_context *) rng, (const int8_t * restrict) f, (const int8_t * restrict) g, (const int8_t * restrict) F, (const int8_t * restrict) G, (const uint16_t *) hm, logn, atmp);
  set_fpu_cw (oldcw);
  es = (uint8_t *) sig;
  es_len = *sig_len;
  memcpy ((void * restrict) (es + 1), nonce, 40);
  u = 41;
  switch (sig_type)
    {
      {
        size_t tu;

                size_t tu;
        case 1:;
        *es = (uint8_t) logn + 48;
        v = falcon_inner_comp_encode ((void *) (es + (sizetype) u), es_len - u, (const int16_t *) sv, logn);
        if (v == 0)
          {
            return -2;
          }
        goto <D.7989>;
        case 2:;
        *es = (uint8_t) logn + 48;
        tu = ((((((256 >> 10 - logn) * 3 + (128 >> 10 - logn) * 2) + (64 >> 10 - logn) * 3) + (16 >> 10 - logn) * 2) - (2 >> 10 - logn) * 2) - (1 >> 10 - logn) * 8) + 44;
        v = falcon_inner_comp_encode ((void *) (es + (sizetype) u), tu - u, (const int16_t *) sv, logn);
        if (v == 0)
          {
            // predicted unlikely by continue predictor.;
            goto <D.7991>;
          }
        if (u + v < tu)
          {
            memset ((void *) (es + ((sizetype) u + (sizetype) v)), 0, tu - (u + v));
            v = tu - u;
          }
        goto <D.7989>;
        case 3:;
        *es = (uint8_t) logn + 80;
        v = falcon_inner_trim_i16_encode ((void *) (es + (sizetype) u), es_len - u, (const int16_t *) sv, logn, (unsigned int) falcon_inner_max_sig_bits[logn]);
        if (v == 0)
          {
            return -2;
          }
        goto <D.7989>;
      }
      <D.7989>:;
    }
  *sig_len = u + v;
  return 0;
  <D.7991>:;
  goto <D.7993>;
}


;; Function falcon_sign_dyn_lazy_finish (null)
;; enabled by -tree-original


{
  unsigned int logn;
  const uint8_t * sk;
  int8_t * f;
  int8_t * g;
  int8_t * F;
  int8_t * G;
  uint16_t * hm;
  int16_t * sv;
  uint8_t * atmp;
  size_t n;
  size_t es_len;
  int8_t * dummy1 = (int8_t *) sig;
  struct shake256_context * dummy2 = hash_data;
  const void * dummy3 = nonce;

    unsigned int logn;
    const uint8_t * sk;
    int8_t * f;
    int8_t * g;
    int8_t * F;
    int8_t * G;
    uint16_t * hm;
    int16_t * sv;
    uint8_t * atmp;
    size_t n;
    size_t es_len;
    int8_t * dummy1 = (int8_t *) sig;
  dummy1 = dummy1 + 1;
    struct shake256_context * dummy2 = hash_data;
  dummy2 = dummy2 + 208;
    const void * dummy3 = nonce;
  dummy3 = dummy3 + 1;
  if (privkey_len == 0)
    {
      return -3;
    }
  sk = (const uint8_t *) privkey;
  if (((int) *sk & 240) != 80)
    {
      return -3;
    }
  logn = (unsigned int) *sk & 15;
  if (logn + 4294967295 > 9)
    {
      return -3;
    }
  if ((logn <= 3 ? (size_t) ((3 << logn) + 1) : (size_t) (((10 - (logn >> 1) << logn + 4294967294) + (unsigned int) (1 << logn)) + 1)) != privkey_len)
    {
      return -3;
    }
  if ((size_t) ((78 << logn) + 7) > tmp_len)
    {
      return -2;
    }
  es_len = *sig_len;
  if (es_len <= 40)
    {
      return -2;
    }
  switch (sig_type)
    {
      case 1:;
      goto <D.8021>;
      case 2:;
      if (*sig_len < (size_t) (((((((256 >> 10 - logn) * 3 + (128 >> 10 - logn) * 2) + (64 >> 10 - logn) * 3) + (16 >> 10 - logn) * 2) - (2 >> 10 - logn) * 2) - (1 >> 10 - logn) * 8) + 44))
        {
          return -2;
        }
      goto <D.8021>;
      case 3:;
      if (*sig_len < (size_t) (((3 << logn + 4294967295) - (logn == 3)) + 41))
        {
          return -2;
        }
      goto <D.8021>;
      default:;
      return -5;
      <D.8021>:;
    }
  n = 1 << logn;
  f = (int8_t *) tmp;
  g = f + (sizetype) n;
  F = g + (sizetype) n;
  G = F + (sizetype) n;
  hm = (uint16_t *) (G + (sizetype) n);
  sv = (int16_t *) hm;
  atmp = align_u64 ((void *) (hm + (sizetype) (n * 2)));
  <D.8025>:;
  falcon_inner_sign_dyn_lazy (sv, (struct inner_shake256_context *) rng, (const int8_t * restrict) f, (const int8_t * restrict) g, (const int8_t * restrict) F, (const int8_t * restrict) G, (const uint16_t *) hm, logn, atmp);
  return 0;
  goto <D.8025>;
}


;; Function falcon_expand_privkey (null)
;; enabled by -tree-original


{
  unsigned int logn;
  const uint8_t * sk;
  int8_t * f;
  int8_t * g;
  int8_t * F;
  int8_t * G;
  uint8_t * atmp;
  size_t u;
  size_t v;
  size_t n;
  fpr * expkey;
  unsigned int oldcw;

    unsigned int logn;
    const uint8_t * sk;
    int8_t * f;
    int8_t * g;
    int8_t * F;
    int8_t * G;
    uint8_t * atmp;
    size_t u;
    size_t v;
    size_t n;
    fpr * expkey;
    unsigned int oldcw;
  if (privkey_len == 0)
    {
      return -3;
    }
  sk = (const uint8_t *) privkey;
  if (((int) *sk & 240) != 80)
    {
      return -3;
    }
  logn = (unsigned int) *sk & 15;
  if (logn + 4294967295 > 9)
    {
      return -3;
    }
  if ((logn <= 3 ? (size_t) ((3 << logn) + 1) : (size_t) (((10 - (logn >> 1) << logn + 4294967294) + (unsigned int) (1 << logn)) + 1)) != privkey_len)
    {
      return -3;
    }
  if ((size_t) (((logn + 5) * 8 << logn) + 8) > expanded_key_len || (size_t) ((52 << logn) + 7) > tmp_len)
    {
      return -2;
    }
  n = 1 << logn;
  f = (int8_t *) tmp;
  g = f + (sizetype) n;
  F = g + (sizetype) n;
  G = F + (sizetype) n;
  atmp = align_u64 ((void *) (G + (sizetype) n));
  u = 1;
  v = falcon_inner_trim_i8_decode (f, logn, (unsigned int) falcon_inner_max_fg_bits[logn], (const void *) (sk + (sizetype) u), privkey_len - u);
  if (v == 0)
    {
      return -3;
    }
  u = u + v;
  v = falcon_inner_trim_i8_decode (g, logn, (unsigned int) falcon_inner_max_fg_bits[logn], (const void *) (sk + (sizetype) u), privkey_len - u);
  if (v == 0)
    {
      return -3;
    }
  u = u + v;
  v = falcon_inner_trim_i8_decode (F, logn, (unsigned int) falcon_inner_max_FG_bits[logn], (const void *) (sk + (sizetype) u), privkey_len - u);
  if (v == 0)
    {
      return -3;
    }
  u = u + v;
  if (u != privkey_len)
    {
      return -3;
    }
  if (falcon_inner_complete_private (G, (const int8_t *) f, (const int8_t *) g, (const int8_t *) F, logn, atmp) == 0)
    {
      return -3;
    }
  *(uint8_t *) expanded_key = (uint8_t) logn;
  expkey = align_fpr (expanded_key + 1);
  oldcw = set_fpu_cw (2);
  falcon_inner_expand_privkey (expkey, (const int8_t *) f, (const int8_t *) g, (const int8_t *) F, (const int8_t *) G, logn, atmp);
  set_fpu_cw (oldcw);
  return 0;
}


;; Function falcon_sign_tree_finish (null)
;; enabled by -tree-original


{
  unsigned int logn;
  uint8_t * es;
  const fpr * expkey;
  uint16_t * hm;
  int16_t * sv;
  uint8_t * atmp;
  size_t u;
  size_t v;
  size_t n;
  size_t es_len;
  unsigned int oldcw;
  struct inner_shake256_context sav_hash_data;

    unsigned int logn;
    uint8_t * es;
    const fpr * expkey;
    uint16_t * hm;
    int16_t * sv;
    uint8_t * atmp;
    size_t u;
    size_t v;
    size_t n;
    size_t es_len;
    unsigned int oldcw;
    struct inner_shake256_context sav_hash_data;
  logn = (unsigned int) *(const uint8_t *) expanded_key;
  if (logn + 4294967295 > 9)
    {
      return -3;
    }
  if ((size_t) ((50 << logn) + 7) > tmp_len)
    {
      return -2;
    }
  es_len = *sig_len;
  if (es_len <= 40)
    {
      return -2;
    }
  expkey = (const fpr *) align_fpr ((void *) expanded_key + 1);
  switch (sig_type)
    {
      case 1:;
      goto <D.8070>;
      case 2:;
      if (*sig_len < (size_t) (((((((256 >> 10 - logn) * 3 + (128 >> 10 - logn) * 2) + (64 >> 10 - logn) * 3) + (16 >> 10 - logn) * 2) - (2 >> 10 - logn) * 2) - (1 >> 10 - logn) * 8) + 44))
        {
          return -2;
        }
      goto <D.8070>;
      case 3:;
      if (*sig_len < (size_t) (((3 << logn + 4294967295) - (logn == 3)) + 41))
        {
          return -2;
        }
      goto <D.8070>;
      default:;
      return -5;
      <D.8070>:;
    }
  n = 1 << logn;
  hm = (uint16_t *) align_u16 (tmp);
  sv = (int16_t *) hm;
  atmp = align_u64 ((void *) (sv + (sizetype) (n * 2)));
  shake256_flip (hash_data);
  sav_hash_data = *(struct inner_shake256_context *) hash_data;
  <D.8080>:;
  *(struct inner_shake256_context *) hash_data = sav_hash_data;
  if (sig_type == 3)
    {
      falcon_inner_hash_to_point_ct ((struct inner_shake256_context *) hash_data, hm, logn, atmp);
    }
  else
    {
      falcon_inner_hash_to_point_vartime ((struct inner_shake256_context *) hash_data, hm, logn);
    }
  oldcw = set_fpu_cw (2);
  falcon_inner_sign_tree (sv, (struct inner_shake256_context *) rng, expkey, (const uint16_t *) hm, logn, atmp);
  set_fpu_cw (oldcw);
  es = (uint8_t *) sig;
  es_len = *sig_len;
  memcpy ((void * restrict) (es + 1), nonce, 40);
  u = 41;
  switch (sig_type)
    {
      {
        size_t tu;

                size_t tu;
        case 1:;
        *es = (uint8_t) logn + 48;
        v = falcon_inner_comp_encode ((void *) (es + (sizetype) u), es_len - u, (const int16_t *) sv, logn);
        if (v == 0)
          {
            return -2;
          }
        goto <D.8076>;
        case 2:;
        *es = (uint8_t) logn + 48;
        tu = ((((((256 >> 10 - logn) * 3 + (128 >> 10 - logn) * 2) + (64 >> 10 - logn) * 3) + (16 >> 10 - logn) * 2) - (2 >> 10 - logn) * 2) - (1 >> 10 - logn) * 8) + 44;
        v = falcon_inner_comp_encode ((void *) (es + (sizetype) u), tu - u, (const int16_t *) sv, logn);
        if (v == 0)
          {
            // predicted unlikely by continue predictor.;
            goto <D.8078>;
          }
        if (u + v < tu)
          {
            memset ((void *) (es + ((sizetype) u + (sizetype) v)), 0, tu - (u + v));
            v = tu - u;
          }
        goto <D.8076>;
        case 3:;
        *es = (uint8_t) logn + 80;
        v = falcon_inner_trim_i16_encode ((void *) (es + (sizetype) u), es_len - u, (const int16_t *) sv, logn, (unsigned int) falcon_inner_max_sig_bits[logn]);
        if (v == 0)
          {
            return -2;
          }
        goto <D.8076>;
      }
      <D.8076>:;
    }
  *sig_len = u + v;
  return 0;
  <D.8078>:;
  goto <D.8080>;
}


;; Function falcon_sign_dyn (null)
;; enabled by -tree-original


{
  struct shake256_context hd;
  uint8_t nonce[40];
  int r;

    struct shake256_context hd;
    uint8_t nonce[40];
    int r;
  r = falcon_sign_start (rng, (void *) &nonce, &hd);
  if (r != 0)
    {
      return r;
    }
  shake256_inject (&hd, data, data_len);
  return falcon_sign_dyn_finish (rng, sig, sig_len, sig_type, privkey, privkey_len, &hd, (const void *) &nonce, tmp, tmp_len);
}


;; Function falcon_sign_dyn_lazy (null)
;; enabled by -tree-original


{
  struct shake256_context hd;
  uint8_t nonce[40];
  int8_t * dummy1 = (int8_t *) data;
  int8_t * dummy3 = (int8_t *) data_len;

    struct shake256_context hd;
    uint8_t nonce[40];
    int8_t * dummy1 = (int8_t *) data;
  dummy1 = dummy1 + 1;
    int8_t * dummy3 = (int8_t *) data_len;
  dummy3 = dummy3 + 1;
  return falcon_sign_dyn_lazy_finish (rng, sig, sig_len, sig_type, privkey, privkey_len, &hd, (const void *) &nonce, tmp, tmp_len);
}


;; Function falcon_sign_tree (null)
;; enabled by -tree-original


{
  struct shake256_context hd;
  uint8_t nonce[40];
  int r;

    struct shake256_context hd;
    uint8_t nonce[40];
    int r;
  r = falcon_sign_start (rng, (void *) &nonce, &hd);
  if (r != 0)
    {
      return r;
    }
  shake256_inject (&hd, data, data_len);
  return falcon_sign_tree_finish (rng, sig, sig_len, sig_type, expanded_key, &hd, (const void *) &nonce, tmp, tmp_len);
}


;; Function falcon_verify_start (null)
;; enabled by -tree-original


{
  if (sig_len <= 40)
    {
      return -3;
    }
  shake256_init (hash_data);
  shake256_inject (hash_data, sig + 1, 40);
  return 0;
}


;; Function falcon_verify_finish (null)
;; enabled by -tree-original


{
  unsigned int logn;
  uint8_t * atmp;
  const uint8_t * pk;
  const uint8_t * es;
  size_t u;
  size_t v;
  size_t n;
  uint16_t * h;
  uint16_t * hm;
  int16_t * sv;
  int ct;

    unsigned int logn;
    uint8_t * atmp;
    const uint8_t * pk;
    const uint8_t * es;
    size_t u;
    size_t v;
    size_t n;
    uint16_t * h;
    uint16_t * hm;
    int16_t * sv;
    int ct;
  if (sig_len <= 40 || pubkey_len == 0)
    {
      return -3;
    }
  es = (const uint8_t *) sig;
  pk = (const uint8_t *) pubkey;
  if (((int) *pk & 240) != 0)
    {
      return -3;
    }
  logn = (unsigned int) *pk & 15;
  if (logn + 4294967295 > 9)
    {
      return -3;
    }
  if (((unsigned int) *es & 15) != logn)
    {
      return -4;
    }
  ct = 0;
  switch (sig_type)
    {
      case 0:;
      switch ((int) *es & 240)
        {
          case 48:;
          goto <D.8154>;
          case 80:;
          if ((size_t) (((3 << logn + 4294967295) - (logn == 3)) + 41) != sig_len)
            {
              return -3;
            }
          ct = 1;
          goto <D.8154>;
          default:;
          return -4;
          <D.8154>:;
        }
      goto <D.8157>;
      case 1:;
      if (((int) *es & 240) != 48)
        {
          return -3;
        }
      goto <D.8157>;
      case 2:;
      if (((int) *es & 240) != 48)
        {
          return -3;
        }
      if ((size_t) (((((((256 >> 10 - logn) * 3 + (128 >> 10 - logn) * 2) + (64 >> 10 - logn) * 3) + (16 >> 10 - logn) * 2) - (2 >> 10 - logn) * 2) - (1 >> 10 - logn) * 8) + 44) != sig_len)
        {
          return -3;
        }
      goto <D.8157>;
      case 3:;
      if (((int) *es & 240) != 80)
        {
          return -3;
        }
      if ((size_t) (((3 << logn + 4294967295) - (logn == 3)) + 41) != sig_len)
        {
          return -3;
        }
      ct = 1;
      goto <D.8157>;
      default:;
      return -5;
      <D.8157>:;
    }
  if ((logn > 1 ? (size_t) ((7 << logn + 4294967294) + 1) : 5) != pubkey_len)
    {
      return -3;
    }
  if ((size_t) ((8 << logn) + 1) > tmp_len)
    {
      return -2;
    }
  n = 1 << logn;
  h = (uint16_t *) align_u16 (tmp);
  hm = h + (sizetype) (n * 2);
  sv = (int16_t *) (hm + (sizetype) (n * 2));
  atmp = (uint8_t *) (sv + (sizetype) (n * 2));
  if (falcon_inner_modq_decode (h, logn, (const void *) (pk + 1), pubkey_len + 4294967295) != pubkey_len + 4294967295)
    {
      return -3;
    }
  u = 41;
  if (ct != 0)
    {
      v = falcon_inner_trim_i16_decode (sv, logn, (unsigned int) falcon_inner_max_sig_bits[logn], (const void *) (es + (sizetype) u), sig_len - u);
    }
  else
    {
      v = falcon_inner_comp_decode (sv, logn, (const void *) (es + (sizetype) u), sig_len - u);
    }
  if (v == 0)
    {
      return -3;
    }
  if (u + v != sig_len)
    {
      if (sig_type == 0 && (size_t) (((((((256 >> 10 - logn) * 3 + (128 >> 10 - logn) * 2) + (64 >> 10 - logn) * 3) + (16 >> 10 - logn) * 2) - (2 >> 10 - logn) * 2) - (1 >> 10 - logn) * 8) + 44) == sig_len || sig_type == 2)
        {
          goto <D.8163>;
          <D.8162>:;
          if (*(es + (sizetype) (u + v)) != 0)
            {
              return -3;
            }
          v++ ;
          <D.8163>:;
          if (u + v < sig_len) goto <D.8162>; else goto <D.8164>;
          <D.8164>:;
        }
      else
        {
          return -3;
        }
    }
  shake256_flip (hash_data);
  if (ct != 0)
    {
      falcon_inner_hash_to_point_ct ((struct inner_shake256_context *) hash_data, hm, logn, atmp);
    }
  else
    {
      falcon_inner_hash_to_point_vartime ((struct inner_shake256_context *) hash_data, hm, logn);
    }
  falcon_inner_to_ntt_monty (h, logn);
  if (falcon_inner_verify_raw ((const uint16_t *) hm, (const int16_t *) sv, (const uint16_t *) h, logn, atmp) == 0)
    {
      return -4;
    }
  return 0;
}


;; Function falcon_verify (null)
;; enabled by -tree-original


{
  struct shake256_context hd;
  int r;

    struct shake256_context hd;
    int r;
  r = falcon_verify_start (&hd, sig, sig_len);
  if (r < 0)
    {
      return r;
    }
  shake256_inject (&hd, data, data_len);
  return falcon_verify_finish (sig, sig_len, sig_type, pubkey, pubkey_len, &hd, tmp, tmp_len);
}

